name: CI

on:
  pull_request:
  workflow_call:

permissions:
  contents: read
  pull-requests: write

jobs:
  ci:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Lint (gerar relatÃ³rio)
        id: lint
        run: npx eslint --config eslint.config.js . -f json -o eslint-report.json || true

      - name: Checagem de arquitetura
        id: architecture
        run: |
          node -e "
          const fs = require('fs');
          const path = require('path');

          // Carregar o checker (local ou do DLF-CI)
          let checkArchitecture;
          const localPath = './.github/workflows/architecture-check.js';
          if (fs.existsSync(localPath)) {
            checkArchitecture = require(localPath).checkArchitecture;
          } else {
            console.log('âš ï¸ architecture-check.js nÃ£o encontrado, pulando anÃ¡lise de arquitetura');
            fs.writeFileSync('architecture-report.json', '[]');
            process.exit(0);
          }

          const files = fs.readdirSync('.', { recursive: true })
            .filter(f => /\.(ts|tsx)$/.test(f) && !f.includes('node_modules') && !f.includes('.d.ts'));

          const issues = [];
          files.forEach(file => {
            const content = fs.readFileSync(file, 'utf8');
            const fileIssues = checkArchitecture(file, content);
            fileIssues.forEach(issue => {
              issues.push({ file, ...issue });
            });
          });

          fs.writeFileSync('architecture-report.json', JSON.stringify(issues, null, 2));
          console.log('ğŸ“Š AnÃ¡lise de arquitetura: ' + issues.length + ' issues encontradas');
          " || true

      - name: Typecheck
        id: typecheck
        run: npm run typecheck 2>&1 | tee typecheck-output.txt
        continue-on-error: true

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Review nas linhas do PR (Files changed) â€” bot submete review para o revisor aprovar
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: ğŸ¤– DLF Agent â€” Review nos arquivos (Files changed)
        if: always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');

            const { owner, repo } = context.repo;
            const pr_number = context.payload.pull_request?.number;
            const commit_id = context.payload.pull_request?.head?.sha;

            if (!pr_number || !commit_id) {
              console.log('NÃ£o Ã© um pull request ou falta commit_id, pulando review');
              return;
            }

            // Paths na API sÃ£o sempre com / (formato do GitHub)
            function normPath(p) {
              return p.replace(/\\/g, '/');
            }

            // â”€â”€ Buscar arquivos modificados no PR â”€â”€
            const { data: prFiles } = await github.rest.pulls.listFiles({
              owner, repo, pull_number: pr_number,
            });
            const modifiedFiles = new Set(prFiles.map(f => f.filename));

            // â”€â”€ Linhas que existem no diff (lado novo do arquivo) â”€â”€
            const diffLines = new Map();
            for (const file of prFiles) {
              const lines = new Set();
              if (file.patch) {
                const patchLines = file.patch.split('\n');
                let currentLine = 0;
                for (const patchLine of patchLines) {
                  const hunkMatch = patchLine.match(/^@@ -\d+(?:,\d+)? \+(\d+)/);
                  if (hunkMatch) {
                    currentLine = parseInt(hunkMatch[1], 10);
                    continue;
                  }
                  if (patchLine.startsWith('+')) {
                    lines.add(currentLine);
                    currentLine++;
                  } else if (patchLine.startsWith('-')) {
                    // nada
                  } else {
                    lines.add(currentLine);
                    currentLine++;
                  }
                }
              }
              diffLines.set(file.filename, lines);
            }

            function isLineInDiff(filePath, line) {
              const normalized = normPath(filePath);
              const fileLines = diffLines.get(normalized);
              if (!fileLines || fileLines.size === 0) return true;
              return fileLines.has(line);
            }

            // â”€â”€ TraduÃ§Ãµes do ESLint â”€â”€
            const translateMessage = (ruleId, message) => {
              const translations = {
                // TypeScript
                '@typescript-eslint/no-unused-vars': (() => {
                  const varName = message.split("'")[1] || 'esta variÃ¡vel';
                  // Detectar se Ã© import
                  if (message.includes('defined but never used')) {
                    return `ğŸ§¹ **Import/variÃ¡vel nÃ£o utilizada**: \`${varName}\` foi declarada mas nunca Ã© usada.\n\nğŸ’¡ **Dica**: Imports e variÃ¡veis sem uso aumentam o bundle e poluem o cÃ³digo. Remova ou adicione \`_\` no inÃ­cio se for intencional (ex: \`_${varName}\`).\nNo VS Code: \`Ctrl+Shift+P â†’ Organize Imports\``;
                  }
                  return `ğŸ§¹ **VariÃ¡vel nÃ£o utilizada**: \`${varName}\` foi declarada mas nunca Ã© usada.\n\nğŸ’¡ **Dica**: Remova variÃ¡veis que nÃ£o estÃ¡ usando. Se precisa manter por algum motivo, adicione \`_\` no inÃ­cio: \`_${varName}\`.`;
                })(),
                '@typescript-eslint/no-unused-expressions': 'ğŸ§¹ **ExpressÃ£o sem efeito** â€” Esta linha nÃ£o faz nada Ãºtil.\n\nğŸ’¡ **Dica**: VocÃª esqueceu de atribuir o resultado a uma variÃ¡vel? Ou de chamar uma funÃ§Ã£o? Verifique se nÃ£o falta um `=` ou `()`.', 
                '@typescript-eslint/no-explicit-any': 'ğŸ“ **Tipo `any` detectado** â€” Evite `any` ao mÃ¡ximo.\n\nğŸ’¡ **Dica**: `any` desabilita a proteÃ§Ã£o do TypeScript. Alternativas:\n- Defina o tipo correto na pasta `/interfaces`\n- Use `unknown` se realmente nÃ£o sabe o tipo\n- Use generics `<T>` para flexibilidade com seguranÃ§a',
                '@typescript-eslint/no-var-requires': 'ğŸ“¦ **Use `import` ES6** â€” Substitua `require()` por `import`.\n\nğŸ’¡ **Dica**: `import` Ã© o padrÃ£o moderno e permite tree-shaking (bundle menor).',
                '@typescript-eslint/consistent-type-definitions': 'ğŸ“ **Use `interface`** â€” Prefira `interface` em vez de `type` para objetos.\n\nğŸ’¡ **Dica**: `interface` pode ser estendida e merged, Ã© mais flexÃ­vel para definiÃ§Ãµes de objetos.',

                // ComentÃ¡rios
                'no-inline-comments': 'ğŸ’¬ **ComentÃ¡rio inline** â€” Evite comentÃ¡rios na mesma linha do cÃ³digo.\n\nğŸ’¡ **Dica**: CÃ³digo limpo Ã© autodocumentÃ¡vel. Se precisa explicar algo, o cÃ³digo provavelmente pode ser simplificado.',
                'line-comment-position': 'ğŸ’¬ **PosiÃ§Ã£o do comentÃ¡rio** â€” ComentÃ¡rios devem ficar acima do cÃ³digo, nÃ£o ao lado.\n\nğŸ’¡ **Dica**: Mas antes, pergunte-se se o comentÃ¡rio Ã© mesmo necessÃ¡rio!',
                'no-warning-comments': 'ğŸ·ï¸ **ComentÃ¡rio temporÃ¡rio** â€” Resolva TODOs e FIXMEs antes de fazer merge.\n\nğŸ’¡ **Dica**: Se nÃ£o pode resolver agora, crie uma Issue no GitHub e referencie no cÃ³digo.',
                'spaced-comment': 'ğŸ’¬ **FormataÃ§Ã£o de comentÃ¡rio** â€” Adicione um espaÃ§o apÃ³s `//` ou `/*`.',

                // Qualidade de cÃ³digo
                'max-lines': `ğŸ“ **Arquivo muito longo** â€” Este arquivo ultrapassou o limite de **200 linhas** do padrÃ£o DLF.\n\nğŸ’¡ **Dica**: Divida em:\n- Componentes menores (atoms/molecules/organisms)\n- Custom hooks em \`/hooks\`\n- Constantes em \`/consts\`\n- Types em \`/interfaces\``,
                'max-lines-per-function': 'ğŸ“ **FunÃ§Ã£o muito longa** â€” Esta funÃ§Ã£o tem muitas linhas.\n\nğŸ’¡ **Dica**: FunÃ§Ãµes devem fazer UMA coisa. Extraia lÃ³gica para funÃ§Ãµes auxiliares, custom hooks ou utilitÃ¡rios.',
                'max-statements': 'ğŸ“ **Muitas declaraÃ§Ãµes** â€” FunÃ§Ã£o com complexidade alta.\n\nğŸ’¡ **Dica**: Muitas variÃ¡veis em uma funÃ§Ã£o indicam responsabilidade demais. Extraia para hooks ou funÃ§Ãµes utilitÃ¡rias.',
                'max-params': 'ğŸ“ **Muitos parÃ¢metros** â€” Use um objeto de configuraÃ§Ã£o.\n\nğŸ’¡ **Dica**: `function foo({ name, age, city }: FooParams)` Ã© mais legÃ­vel que `function foo(name, age, city)`.',
                'complexity': 'ğŸ§  **Complexidade alta** â€” Muitos caminhos de execuÃ§Ã£o.\n\nğŸ’¡ **Dica**: Reduza if/else aninhados. Use early returns, guard clauses, ou extraia condiÃ§Ãµes para funÃ§Ãµes.',
                'max-depth': 'ğŸ§  **Aninhamento excessivo** â€” Muitos nÃ­veis de if/for.\n\nğŸ’¡ **Dica**: Use early returns para reduzir aninhamento:\n```tsx\nif (!condition) return\n// cÃ³digo principal sem aninhamento\n```',
                'max-nested-callbacks': 'ğŸ§  **Callbacks aninhados** â€” Prefira async/await.\n\nğŸ’¡ **Dica**: Callbacks dentro de callbacks sÃ£o difÃ­ceis de ler. Use `async/await` para cÃ³digo mais limpo.',

                // Console
                'no-console': 'ğŸ§¹ **`console.log` detectado** â€” Remova antes de fazer merge.\n\nğŸ’¡ **Dica**: Para feedback ao usuÃ¡rio use **Toast**. Para debug use breakpoints. Para monitoramento use Sentry.',

                // Next.js
                '@next/next/no-html-link-for-pages': 'âš¡ **Use `<Link>` do Next.js** â€” Substitua `<a href>` por `<Link>`.\n\nğŸ’¡ **Dica**: `<Link>` faz prefetch automÃ¡tico e navegaÃ§Ã£o client-side (mais rÃ¡pido!).',
                '@next/next/no-img-element': 'âš¡ **Use `<Image>` do Next.js** â€” Substitua `<img>` por `<Image>`.\n\nğŸ’¡ **Dica**: `<Image>` otimiza automaticamente: lazy loading, resize, WebP, blur placeholder.',
                '@next/next/no-sync-scripts': 'âš¡ **Script sÃ­ncrono detectado** â€” Use `<Script>` do Next.js.\n\nğŸ’¡ **Dica**: Scripts sÃ­ncronos bloqueiam o render. Use `<Script strategy="afterInteractive">` ou `lazyOnload`.',
                '@next/next/no-page-custom-font': 'âš¡ **Use `next/font`** â€” Fontes customizadas devem usar o sistema de fontes do Next.js.\n\nğŸ’¡ **Dica**: `next/font` elimina layout shift e faz subset automÃ¡tico.',

                // React
                'react/jsx-key': 'ğŸ”‘ **Faltou prop `key`** â€” Elementos em listas precisam de `key` Ãºnica.\n\nğŸ’¡ **Dica**: Use IDs do banco como key. Evite usar index como key em listas que podem mudar.',
                'react/jsx-no-duplicate-props': 'ğŸš« **Props duplicadas** â€” VocÃª declarou a mesma prop mais de uma vez.',
                'react/jsx-no-undef': (() => {
                  const comp = message.split("'")[1] || 'Este componente';
                  return `ğŸš« **\`${comp}\` nÃ£o definido** â€” Verifique se importou corretamente.\n\nğŸ’¡ **Dica**: Verifique o nome do import e o caminho do arquivo.`;
                })(),
                'react/no-children-prop': 'ğŸš« **Uso incorreto de children** â€” Use `<Comp>conteÃºdo</Comp>` em vez de `<Comp children="..." />`.',
                'react/no-danger-with-children': 'ğŸš« **Conflito perigoso** â€” NÃ£o use `dangerouslySetInnerHTML` com children.',
                'react/no-deprecated': 'âš ï¸ **API deprecated** â€” Este recurso do React estÃ¡ descontinuado. Consulte a documentaÃ§Ã£o.',
                'react/no-direct-mutation-state': 'ğŸš« **MutaÃ§Ã£o direta de state** â€” Use `setState()` ou `useState` setter.',
                'react/no-unescaped-entities': 'âš ï¸ **Entidade nÃ£o escapada** â€” Use `{\'texto\'}` ou `&quot;` para caracteres especiais em JSX.',
                'react/self-closing-comp': 'ğŸ§¹ **Tag nÃ£o auto-fechada** â€” Use `<Comp />` em vez de `<Comp></Comp>` quando nÃ£o tem children.',

                // React Hooks
                'react-hooks/rules-of-hooks': 'ğŸš« **Regra de Hooks violada** â€” Hooks sÃ³ podem ser chamados no nÃ­vel superior.\n\nğŸ’¡ **Dica**: NUNCA use hooks dentro de if, for, ou funÃ§Ãµes aninhadas. Se precisa de lÃ³gica condicional, use dentro do hook.',
                'react-hooks/exhaustive-deps': 'âš ï¸ **DependÃªncias faltando** â€” O array de dependÃªncias do hook estÃ¡ incompleto.\n\nğŸ’¡ **Dica**: Adicione todas as variÃ¡veis usadas dentro do callback ao array de dependÃªncias. Ou use `useCallback`/`useMemo` para estabilizar referÃªncias.',
              };

              return translations[ruleId] || `**${ruleId}**: ${message}`;
            };

            // â”€â”€ Coletar TODOS os comentÃ¡rios para enviar numa Ãºnica Review (aparece em Files changed) â”€â”€
            const reviewComments = [];
            let hasLintErrors = false;

            // ESLint
            if (fs.existsSync('eslint-report.json')) {
              const report = JSON.parse(fs.readFileSync('eslint-report.json', 'utf8'));
              const filesWithErrors = report.filter(f => f.messages.length > 0);

              for (const file of filesWithErrors) {
                const relativePath = normPath(path.relative(process.cwd(), file.filePath));
                if (!modifiedFiles.has(relativePath)) continue;

                for (const msg of file.messages) {
                  if (!isLineInDiff(relativePath, msg.line)) continue;
                  if (msg.severity === 2) hasLintErrors = true;

                  const translatedMessage = translateMessage(msg.ruleId, msg.message);
                  const severity = msg.severity === 2 ? 'ğŸš« **ERRO**' : 'âš ï¸ **ATENÃ‡ÃƒO**';

                  reviewComments.push({
                    path: relativePath,
                    line: msg.line,
                    body: [severity, '', translatedMessage, '', '---', `<sub>Regra: \`${msg.ruleId}\` | ğŸ¤– DLF Review Agent</sub>`].join('\n'),
                  });
                }
              }
            }

            // Arquitetura
            if (fs.existsSync('architecture-report.json')) {
              const archIssues = JSON.parse(fs.readFileSync('architecture-report.json', 'utf8'));

              for (const issue of archIssues) {
                const filePath = normPath(issue.file);
                if (!modifiedFiles.has(filePath)) continue;
                if (!isLineInDiff(filePath, issue.line)) continue;

                const severityIcon = issue.severity === 'error' ? 'ğŸš« **ERRO**' : 'ğŸ’¡ **SUGESTÃƒO**';

                reviewComments.push({
                  path: filePath,
                  line: issue.line,
                  body: [severityIcon, '', issue.message, '', '---', `<sub>Categoria: \`${issue.category || 'architecture'}\` | ğŸ¤– DLF Review Agent</sub>`].join('\n'),
                });
              }
            }

            // â”€â”€ Deduplicar: agrupar comentÃ¡rios da mesma linha em um sÃ³ â”€â”€
            const grouped = new Map();
            for (const c of reviewComments) {
              const key = `${c.path}::${c.line}`;
              if (grouped.has(key)) {
                const existing = grouped.get(key);
                existing.body += '\n\n---\n\n' + c.body;
              } else {
                grouped.set(key, { ...c });
              }
            }
            const dedupedComments = [...grouped.values()];

            // COMMENT quando tem avisos/sugestÃµes, REQUEST_CHANGES quando tem erros de lint
            // Nunca usa APPROVE (GitHub Actions nÃ£o tem permissÃ£o para aprovar PRs)
            const event = hasLintErrors ? 'REQUEST_CHANGES' : 'COMMENT';
            const reviewBody = dedupedComments.length > 0
              ? `ğŸ¤– **DLF Code Review Agent** analisou este PR e deixou **${dedupedComments.length}** comentÃ¡rio(s) nas linhas dos arquivos.\n\nRevise em **Files changed** e aprove quando estiver ok.`
              : 'ğŸ¤– **DLF Code Review Agent**: Nenhum problema encontrado nos arquivos alterados. âœ…';

            try {
              await github.rest.pulls.createReview({
                owner,
                repo,
                pull_number: pr_number,
                commit_id,
                event,
                body: reviewBody,
                comments: dedupedComments,
              });
              console.log('âœ… Review submetida: ' + dedupedComments.length + ' comentÃ¡rio(s) em Files changed (event: ' + event + ')');
            } catch (error) {
              console.error('Erro ao submeter review:', error.message);
              if (error.response) console.error('Detalhes:', JSON.stringify(error.response.data, null, 2));
            }

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Resumo do agente (comentÃ¡rio principal)
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: ğŸ¤– DLF Agent â€” Resumo da Review
        if: always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const { owner, repo } = context.repo;
            const pr_number = context.payload.pull_request?.number;

            if (!pr_number) return;

            // â”€â”€ Coletar dados â”€â”€
            let lintErrors = 0, lintWarnings = 0;
            let lintErrorFiles = [], lintWarningFiles = [];

            if (fs.existsSync('eslint-report.json')) {
              const report = JSON.parse(fs.readFileSync('eslint-report.json', 'utf8'));
              for (const file of report) {
                const relativePath = file.filePath.replace(process.cwd() + '/', '');
                if (file.errorCount > 0) {
                  lintErrors += file.errorCount;
                  lintErrorFiles.push(relativePath);
                }
                if (file.warningCount > 0) {
                  lintWarnings += file.warningCount;
                  lintWarningFiles.push(relativePath);
                }
              }
            }

            let archIssues = [];
            if (fs.existsSync('architecture-report.json')) {
              archIssues = JSON.parse(fs.readFileSync('architecture-report.json', 'utf8'));
            }

            const typecheckFailed = '${{ steps.typecheck.outcome }}' === 'failure';
            let typecheckOutput = '';
            if (fs.existsSync('typecheck-output.txt')) {
              typecheckOutput = fs.readFileSync('typecheck-output.txt', 'utf8');
            }

            // â”€â”€ Categorizar issues de arquitetura â”€â”€
            const archCategories = {};
            for (const issue of archIssues) {
              const cat = issue.category || 'other';
              if (!archCategories[cat]) archCategories[cat] = [];
              archCategories[cat].push(issue);
            }

            const totalIssues = lintErrors + lintWarnings + archIssues.length + (typecheckFailed ? 1 : 0);

            // â”€â”€ Se zero issues, elogie â”€â”€
            if (totalIssues === 0 && !typecheckFailed) {
              const body = [
                '## ğŸ¤– DLF Code Review Agent',
                '',
                '### âœ… PR impecÃ¡vel! ParabÃ©ns! ğŸ‰',
                '',
                'Nenhum problema encontrado. Seu cÃ³digo estÃ¡:',
                '- âœ… Sem erros de lint',
                '- âœ… Sem problemas de TypeScript',
                '- âœ… Seguindo os padrÃµes de arquitetura DLF',
                '',
                'Continue assim! CÃ³digo limpo e bem organizado facilita a vida de todo o time. ğŸ’ª',
                '',
                '---',
                '<sub>ğŸ¤– DLF Code Review Agent v2.0</sub>',
              ].join('\n');

              const marker = '## ğŸ¤– DLF Code Review Agent';
              const comments = await github.paginate(github.rest.issues.listComments, { owner, repo, issue_number: pr_number });
              const existing = comments.find(c => c.user?.login === 'github-actions[bot]' && c.body?.includes(marker));

              if (existing) {
                await github.rest.issues.updateComment({ owner, repo, comment_id: existing.id, body });
              } else {
                await github.rest.issues.createComment({ owner, repo, issue_number: pr_number, body });
              }
              return;
            }

            // â”€â”€ Construir resumo â”€â”€
            const sections = [];

            sections.push('## ğŸ¤– DLF Code Review Agent');
            sections.push('');
            sections.push('OlÃ¡! Analisei seu PR e aqui estÃ¡ o resumo da review:');
            sections.push('');

            // â”€â”€ Tabela resumo â”€â”€
            sections.push('### ğŸ“Š VisÃ£o Geral');
            sections.push('');
            sections.push('| Categoria | Quantidade | Status |');
            sections.push('|-----------|:----------:|:------:|');

            if (lintErrors > 0)
              sections.push(`| ğŸš« Erros de Lint | ${lintErrors} | âŒ Bloqueia merge |`);
            if (lintWarnings > 0)
              sections.push(`| âš ï¸ Avisos de Lint | ${lintWarnings} | Corrigir recomendado |`);
            if (typecheckFailed)
              sections.push(`| ğŸ”´ TypeScript | Erros | âŒ Bloqueia merge |`);
            if (archIssues.length > 0)
              sections.push(`| ğŸ’¡ SugestÃµes de Arquitetura | ${archIssues.length} | Melhorias recomendadas |`);

            sections.push('');

            // â”€â”€ Erros de TypeScript â”€â”€
            if (typecheckFailed && typecheckOutput) {
              sections.push('### ğŸ”´ Erros de TypeScript');
              sections.push('');
              const tsErrors = typecheckOutput.split('\n')
                .filter(l => /error TS\d+/.test(l))
                .slice(0, 10);
              if (tsErrors.length > 0) {
                sections.push('```');
                sections.push(tsErrors.join('\n'));
                sections.push('```');
              }
              sections.push('');
              sections.push('ğŸ’¡ **Dica**: Rode `npm run typecheck` localmente para ver todos os erros e corrigi-los antes do push.');
              sections.push('');
            }

            // â”€â”€ SeÃ§Ã£o de Arquitetura por categoria â”€â”€
            if (archIssues.length > 0) {
              sections.push('### ğŸ—ï¸ Arquitetura & OrganizaÃ§Ã£o');
              sections.push('');

              const categoryLabels = {
                'file-size': 'ğŸ“ Tamanho de Arquivo',
                'comment': 'ğŸ’¬ ComentÃ¡rios',
                'commented-code': 'ğŸ—‘ï¸ CÃ³digo Comentado',
                'todo-comment': 'ğŸ·ï¸ TODOs/FIXMEs',
                'inline-comment': 'ğŸ’¬ ComentÃ¡rios Inline',
                'unused-import': 'ğŸ§¹ Imports NÃ£o Utilizados',
                'console-log': 'ğŸ§¹ Console.log',
                'console-in-catch': 'ğŸ§¹ Console em Catch',
                'large-constant': 'ğŸ“¦ Constantes Extensas',
                'scattered-constants': 'ğŸ“¦ Constantes Dispersas',
                'multiple-components': 'ğŸ§© MÃºltiplos Componentes',
                'inline-type': 'ğŸ“ Types Inline',
                'long-function': 'ğŸ“ FunÃ§Ãµes Longas',
                'repetitive-pattern': 'ğŸ”„ PadrÃµes Repetitivos',
                'too-many-params': 'ğŸ“ Muitos ParÃ¢metros',
                'hook-placement': 'ğŸª Hooks',
                'hook-extraction': 'ğŸª ExtraÃ§Ã£o de Hooks',
                'supabase-in-component': 'ğŸ—„ï¸ Supabase no Componente',
                'fetch-in-component': 'ğŸŒ Fetch no Componente',
                'large-jsx': 'ğŸ§© JSX Extenso',
                'too-many-states': 'ğŸ§  Muitos Estados',
                'atomic-design': 'ğŸ—ï¸ Atomic Design',
                'duplicate-pattern': 'ğŸ”„ PadrÃµes Duplicados',
              };

              for (const [cat, issues] of Object.entries(archCategories)) {
                const label = categoryLabels[cat] || cat;
                const fileList = [...new Set(issues.map(i => i.file))];
                sections.push(`- **${label}** (${issues.length}) â€” ${fileList.map(f => `\`${f}\``).join(', ')}`);
              }
              sections.push('');
            }

            // â”€â”€ Dicas educacionais baseadas nos problemas encontrados â”€â”€
            sections.push('### ğŸ’¡ Dicas do DLF Agent');
            sections.push('');

            const tips = [];

            if (archCategories['comment'] || archCategories['inline-comment'] || archCategories['commented-code']) {
              tips.push('**CÃ³digo limpo nÃ£o precisa de comentÃ¡rios!** Use nomes descritivos para variÃ¡veis e funÃ§Ãµes. Se algo Ã© complexo demais para entender sem comentÃ¡rio, simplifique a lÃ³gica.');
            }
            if (archCategories['console-log'] || archCategories['console-in-catch']) {
              tips.push('**Substitua `console.log` por Toast!** O usuÃ¡rio nÃ£o vÃª o console. Use `toast.success()` para feedback positivo e `toast.error()` para erros. Para monitoramento, use Sentry.');
            }
            if (archCategories['large-constant'] || archCategories['scattered-constants']) {
              tips.push('**Constantes grandes merecem arquivo prÃ³prio.** Crie na pasta `/consts` quando uma constante passar de 10 linhas. Isso facilita imports seletivos e mantÃ©m os arquivos enxutos.');
            }
            if (archCategories['unused-import']) {
              tips.push('**Organize seus imports!** No VS Code, use `Ctrl+Shift+P â†’ Organize Imports` para remover imports nÃ£o utilizados automaticamente.');
            }
            if (archCategories['too-many-states'] || archCategories['hook-extraction']) {
              tips.push('**Componentes com 4+ useState precisam de um custom hook.** Extraia a lÃ³gica de estado para `hooks/use-nome.ts` â€” seu componente ficarÃ¡ mais limpo e testÃ¡vel.');
            }
            if (archCategories['multiple-components']) {
              tips.push('**Um arquivo, um componente.** No Atomic Design, cada componente tem seu prÃ³prio arquivo. Isso facilita testes, reutilizaÃ§Ã£o e code review.');
            }
            if (archCategories['inline-type']) {
              tips.push('**Types e interfaces devem ficar em `/interfaces` ou `/types`.** Isso permite reutilizaÃ§Ã£o e evita dependÃªncias circulares.');
            }
            if (archCategories['long-function'] || archCategories['repetitive-pattern']) {
              tips.push('**FunÃ§Ãµes devem fazer UMA coisa.** Se passou de 30 linhas, provavelmente faz coisas demais. Extraia validaÃ§Ãµes, transformaÃ§Ãµes e chamadas de API para funÃ§Ãµes auxiliares.');
            }
            if (archCategories['file-size']) {
              tips.push('**Nosso padrÃ£o Ã© mÃ¡ximo 200 linhas por arquivo.** Arquivos menores sÃ£o mais fÃ¡ceis de entender, testar e revisar. Divida em componentes, hooks e utilitÃ¡rios.');
            }
            if (archCategories['fetch-in-component'] || archCategories['supabase-in-component']) {
              tips.push('**Centralize chamadas de API.** Crie funÃ§Ãµes em `/lib` e consuma via custom hooks. Isso facilita cache, revalidaÃ§Ã£o e tratamento de erros consistente.');
            }

            // Sempre adicionar uma dica geral
            if (tips.length === 0) {
              tips.push('Bom trabalho no geral! Revise os avisos acima para deixar o cÃ³digo ainda melhor.');
            }

            tips.forEach((tip, i) => {
              sections.push(`${i + 1}. ${tip}`);
            });
            sections.push('');

            // â”€â”€ PrÃ³ximos passos â”€â”€
            sections.push('### âœ… PrÃ³ximos Passos');
            sections.push('');

            if (lintErrors > 0 || typecheckFailed) {
              sections.push('1. ğŸš« **Corrija os erros** â€” eles bloqueiam o merge do PR');
              sections.push('2. âš ï¸ **Resolva os avisos** â€” melhoram significativamente a qualidade');
              sections.push('3. ğŸ’¡ **Considere as sugestÃµes** â€” sÃ£o opcionais mas muito recomendadas');
              sections.push('');
              sections.push('**Rode localmente antes de fazer push:**');
              sections.push('```bash');
              sections.push('npm run lint      # verificar erros de lint');
              sections.push('npm run typecheck # verificar tipos TypeScript');
              sections.push('```');
            } else {
              sections.push('1. âš ï¸ **Resolva os avisos** â€” melhoram a qualidade do cÃ³digo');
              sections.push('2. ğŸ’¡ **Considere as sugestÃµes** â€” sÃ£o opcionais mas recomendadas');
              sections.push('3. âœ… O CI estÃ¡ passando â€” bom trabalho!');
            }

            sections.push('');
            sections.push('---');
            sections.push('<sub>ğŸ¤– DLF Code Review Agent v2.0 â€” Analisando PRs para que vocÃª aprenda mais rÃ¡pido</sub>');

            const body = sections.join('\n');
            const marker = '## ğŸ¤– DLF Code Review Agent';

            // Atualizar ou criar comentÃ¡rio
            const comments = await github.paginate(github.rest.issues.listComments, { owner, repo, issue_number: pr_number });
            const existing = comments.find(c => c.user?.login === 'github-actions[bot]' && c.body?.includes(marker));

            if (existing) {
              await github.rest.issues.updateComment({ owner, repo, comment_id: existing.id, body });
            } else {
              await github.rest.issues.createComment({ owner, repo, issue_number: pr_number, body });
            }

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Verificar se CI falhou
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Verificar se CI falhou
        if: always()
        run: |
          FAILED=0

          if [ -f eslint-report.json ]; then
            ERRORS=$(node -e "const r = require('./eslint-report.json'); console.log(r.reduce((acc, f) => acc + f.errorCount, 0))")
            if [ "$ERRORS" -gt 0 ]; then
              echo "âŒ Encontrados $ERRORS erros de lint"
              FAILED=1
            fi
          fi

          if [ "${{ steps.typecheck.outcome }}" == "failure" ]; then
            echo "âŒ TypeCheck falhou"
            FAILED=1
          fi

          if [ "$FAILED" -eq 1 ]; then
            echo ""
            echo "ğŸ’¡ Dica: Rode localmente antes de fazer push:"
            echo "   npm run lint"
            echo "   npm run typecheck"
            exit 1
          fi

          echo "âœ… CI passou com sucesso!"
