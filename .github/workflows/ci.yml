name: CI

on:
  pull_request:
  workflow_call:

permissions:
  contents: read
  pull-requests: write

jobs:
  ci:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Lint (gerar relatÃ³rio)
        id: lint
        run: npx eslint --config eslint.config.js . -f json -o eslint-report.json || true

      - name: Checagem de arquitetura
        id: architecture
        run: |
          node -e "
          const fs = require('fs');
          const path = require('path');

          // Carregar o checker (local ou do DLF-CI)
          let checkArchitecture;
          const localPath = './.github/workflows/architecture-check.js';
          if (fs.existsSync(localPath)) {
            checkArchitecture = require(localPath).checkArchitecture;
          } else {
            console.log('âš ï¸ architecture-check.js nÃ£o encontrado, pulando anÃ¡lise de arquitetura');
            fs.writeFileSync('architecture-report.json', '[]');
            process.exit(0);
          }

          const files = fs.readdirSync('.', { recursive: true })
            .filter(f => /\.(ts|tsx)$/.test(f) && !f.includes('node_modules') && !f.includes('.d.ts'));

          const issues = [];
          files.forEach(file => {
            const content = fs.readFileSync(file, 'utf8');
            const fileIssues = checkArchitecture(file, content);
            fileIssues.forEach(issue => {
              issues.push({ file, ...issue });
            });
          });

          fs.writeFileSync('architecture-report.json', JSON.stringify(issues, null, 2));
          console.log('ğŸ“Š AnÃ¡lise de arquitetura: ' + issues.length + ' issues encontradas');
          " || true

      - name: Typecheck
        id: typecheck
        run: npm run typecheck 2>&1 | tee typecheck-output.txt
        continue-on-error: true

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Review nas linhas do PR (Files changed) â€” bot submete review para o revisor aprovar
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: ğŸ¤– DLF Agent â€” Review nos arquivos (Files changed)
        if: always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');

            const { owner, repo } = context.repo;
            const pr_number = context.payload.pull_request?.number;
            const commit_id = context.payload.pull_request?.head?.sha;

            if (!pr_number || !commit_id) {
              console.log('NÃ£o Ã© um pull request ou falta commit_id, pulando review');
              return;
            }

            // Paths na API sÃ£o sempre com / (formato do GitHub)
            function normPath(p) {
              return p.replace(/\\/g, '/');
            }

            // â”€â”€ Buscar arquivos modificados no PR â”€â”€
            const { data: prFiles } = await github.rest.pulls.listFiles({
              owner, repo, pull_number: pr_number,
            });
            const modifiedFiles = new Set(prFiles.map(f => f.filename));

            // â”€â”€ Linhas que existem no diff (lado novo do arquivo) â”€â”€
            const diffLines = new Map();
            for (const file of prFiles) {
              const lines = new Set();
              if (file.patch) {
                const patchLines = file.patch.split('\n');
                let currentLine = 0;
                for (const patchLine of patchLines) {
                  if (patchLine.startsWith('@@')) {
                    const hunkMatch = patchLine.match(/^@@ -\d+(?:,\d+)? \+(\d+)/);
                    if (hunkMatch) currentLine = Math.max(1, parseInt(hunkMatch[1], 10));
                    continue;
                  }
                  if (patchLine.startsWith('\\')) continue;
                  if (patchLine.startsWith('+')) {
                    if (currentLine >= 1) lines.add(currentLine);
                    currentLine++;
                  } else if (patchLine.startsWith('-')) {
                    // nada
                  } else {
                    if (currentLine >= 1) lines.add(currentLine);
                    currentLine++;
                  }
                }
              }
              diffLines.set(file.filename, lines);
            }

            function isLineInDiff(filePath, line) {
              const normalized = normPath(filePath);
              const fileLines = diffLines.get(normalized);
              if (!fileLines || fileLines.size === 0) return false;
              return fileLines.has(line);
            }

            /** Converte array de linhas em ranges: "L19, L21â€“L23, L30" */
            function compressLineNumbers(lines) {
              const sorted = [...new Set(lines)].filter(Number).sort((a, b) => a - b);
              if (sorted.length === 0) return '';
              const ranges = [];
              let start = sorted[0], end = sorted[0];
              for (let i = 1; i <= sorted.length; i++) {
                if (i < sorted.length && sorted[i] === end + 1) {
                  end = sorted[i];
                } else {
                  ranges.push(start === end ? `L${start}` : `L${start}â€“L${end}`);
                  if (i < sorted.length) { start = sorted[i]; end = sorted[i]; }
                }
              }
              return ranges.join(', ');
            }

            /** Para file-level: Ã¢ncora na Ãºltima linha do diff. GitHub sÃ³ aceita linha no diff; sem diff â†’ null (vai pro body). */
            function getAnchorLineEnd(filePath) {
              const normalized = normPath(filePath);
              const fileLines = diffLines.get(normalized);
              if (fileLines && fileLines.size > 0) return Math.max(...fileLines);
              return null;
            }

            // Mensagens canÃ´nicas por categoria (evita duplicaÃ§Ã£o semÃ¢ntica)
            const CANONICAL_MESSAGES = {
              'comment': 'ğŸ’¬ **ComentÃ¡rios no cÃ³digo** â€” remova ou reduza. CÃ³digo autodocumentÃ¡vel Ã© o padrÃ£o DLF.',
              'commented-code': 'ğŸ—‘ï¸ **CÃ³digo comentado** â€” remova. O Git guarda o histÃ³rico.',
              'todo-comment': 'ğŸ·ï¸ **TODO/FIXME** â€” resolva antes de mergear ou crie uma Issue.',
              'unused-import': 'ğŸ§¹ **Imports nÃ£o utilizados** â€” remova. VS Code: Organize Imports.',
              'console-log': 'ğŸ§¹ **console** â€” remova. Use Toast para feedback.',
              'console-in-catch': 'ğŸ§¹ **console em catch** â€” use Toast ou Sentry.',
              'file-size': 'ğŸ“ **Arquivo muito longo** â€” divida em componentes/hooks (mÃ¡x. 200 linhas).',
              'hook-placement': 'ğŸª **Hooks** sÃ³ no nÃ­vel superior do componente.',
              'hook-extraction': 'ğŸª **Extraia lÃ³gica** para um custom hook.',
              'scattered-constants': 'ğŸ“¦ **Constantes dispersas** â€” mova para `/consts`.',
              'atomic-design': 'ğŸ—ï¸ **Atomic Design** â€” um componente por arquivo.',
              'large-constant': 'ğŸ“¦ **Constante grande** â€” mova para arquivo em `/consts`.',
              'multiple-components': 'ğŸ§© **MÃºltiplos componentes** â€” um arquivo, um componente.',
              'inline-type': 'ğŸ“ **Types inline** â€” mova para `/interfaces` ou `/types`.',
              'long-function': 'ğŸ“ **FunÃ§Ã£o longa** â€” extraia para funÃ§Ãµes menores.',
              'repetitive-pattern': 'ğŸ”„ **PadrÃ£o repetitivo** â€” extraia funÃ§Ã£o/hook.',
              'too-many-params': 'ğŸ“ **Muitos parÃ¢metros** â€” use objeto de opÃ§Ãµes.',
              'too-many-states': 'ğŸ§  **Muitos estados** â€” extraia para custom hook.',
              'duplicate-pattern': 'ğŸ”„ **PadrÃ£o duplicado** â€” extraia e reutilize.',
              'large-jsx': 'ğŸ§© **JSX extenso** â€” extraia subcomponentes.',
              'supabase-in-component': 'ğŸ—„ï¸ **Supabase no componente** â€” mova para `/lib` ou hook.',
              'fetch-in-component': 'ğŸŒ **Fetch no componente** â€” centralize em `/lib` ou hook.',
            };

            const translateMessage = (ruleId, message) => {
              const varName = message.split("'")[1] || '';
              const translations = {
                '@typescript-eslint/no-unused-vars': `ğŸ§¹ **NÃ£o utilizado**: \`${varName || 'variÃ¡vel'}\` â€” remova ou prefixe com \`_\`.`,
                '@typescript-eslint/no-unused-expressions': 'ğŸ§¹ **ExpressÃ£o sem efeito** â€” falta atribuiÃ§Ã£o ou chamada?',
                '@typescript-eslint/no-explicit-any': 'ğŸ“ **Evite `any`** â€” use tipo em `/interfaces` ou `unknown`.',
                '@typescript-eslint/no-var-requires': 'ğŸ“¦ **Use `import`** em vez de `require()`.',
                '@typescript-eslint/consistent-type-definitions': 'ğŸ“ **Use `interface`** em vez de `type` para objetos.',
                'no-inline-comments': 'ğŸ’¬ **ComentÃ¡rio inline** â€” remova ou mova para linha acima.',
                'line-comment-position': 'ğŸ’¬ **ComentÃ¡rio na posiÃ§Ã£o errada** â€” mova para linha acima.',
                'no-warning-comments': 'ğŸ·ï¸ **TODO/FIXME** â€” resolva antes de mergear.',
                'spaced-comment': 'ğŸ’¬ Adicione espaÃ§o apÃ³s `//`.',
                'max-lines': 'ğŸ“ **Arquivo muito longo** â€” divida o arquivo.',
                'max-lines-per-function': 'ğŸ“ **FunÃ§Ã£o muito longa** â€” extraia lÃ³gica.',
                'max-statements': 'ğŸ“ **Muitas declaraÃ§Ãµes** â€” extraia hooks/utilitÃ¡rios.',
                'max-params': 'ğŸ“ **Muitos parÃ¢metros** â€” use objeto de configuraÃ§Ã£o.',
                'complexity': 'ğŸ§  **Complexidade alta** â€” simplifique ou extraia funÃ§Ãµes.',
                'max-depth': 'ğŸ§  **Aninhamento excessivo** â€” use early returns.',
                'max-nested-callbacks': 'ğŸ§  **Callbacks aninhados** â€” use async/await.',
                'no-console': 'ğŸ§¹ **console** â€” remova. Use Toast.',
                '@next/next/no-html-link-for-pages': 'âš¡ Use `<Link>` do Next.js.',
                '@next/next/no-img-element': 'âš¡ Use `<Image>` do Next.js.',
                '@next/next/no-sync-scripts': 'âš¡ Use `<Script>` do Next.js.',
                '@next/next/no-page-custom-font': 'âš¡ Use `next/font`.',
                'react/jsx-key': 'ğŸ”‘ **Faltou `key`** em lista.',
                'react/jsx-no-duplicate-props': 'ğŸš« **Props duplicadas**.',
                'react/jsx-no-undef': `ğŸš« **\`${varName || 'Componente'}\` nÃ£o definido** â€” verifique import.`,
                'react/no-children-prop': 'ğŸš« Use `<Comp>conteÃºdo</Comp>` em vez de prop children.',
                'react/no-danger-with-children': 'ğŸš« NÃ£o use dangerouslySetInnerHTML com children.',
                'react/no-deprecated': 'âš ï¸ **API deprecated**.',
                'react/no-direct-mutation-state': 'ğŸš« Use setState() ou useState setter.',
                'react/no-unescaped-entities': 'âš ï¸ Escape caracteres em JSX.',
                'react/self-closing-comp': 'ğŸ§¹ Use `<Comp />` sem children.',
                'react-hooks/rules-of-hooks': 'ğŸš« **Hooks** sÃ³ no nÃ­vel superior.',
                'react-hooks/exhaustive-deps': 'âš ï¸ **DependÃªncias faltando** no array do hook.',
              };
              return translations[ruleId] || `**${ruleId}**: ${message}`;
            };

            const reviewComments = [];
            const bodyOnlyLines = [];
            let hasLintErrors = false;

            const SKIP_ESLINT_RULES = new Set([
              'no-console', 'no-inline-comments', 'line-comment-position', 'no-warning-comments',
              'spaced-comment', 'max-lines', 'max-lines-per-function', 'max-statements', 'max-params',
              '@typescript-eslint/no-unused-vars',
            ]);

            // ESLint â€” agrupar por { path, ruleId }, 1 comentÃ¡rio por grupo com ranges
            if (fs.existsSync('eslint-report.json')) {
              const report = JSON.parse(fs.readFileSync('eslint-report.json', 'utf8'));
              const byPathRule = new Map();
              for (const file of report.filter(f => f.messages.length > 0)) {
                const relativePath = normPath(path.relative(process.cwd(), file.filePath));
                if (!modifiedFiles.has(relativePath)) continue;
                for (const msg of file.messages) {
                  if (SKIP_ESLINT_RULES.has(msg.ruleId)) continue;
                  if (msg.severity === 2) hasLintErrors = true;
                  const key = `${relativePath}::${msg.ruleId}`;
                  if (!byPathRule.has(key)) byPathRule.set(key, []);
                  byPathRule.get(key).push({ line: msg.line, message: msg.message, ruleId: msg.ruleId });
                }
              }
              for (const [key, items] of byPathRule) {
                const [relativePath, ruleId] = key.split('::');
                const lines = items.map(i => i.line);
                const inDiff = lines.filter(l => isLineInDiff(relativePath, l));
                const anchor = inDiff.length > 0 ? Math.min(...inDiff) : null;
                const ranges = compressLineNumbers(lines);
                const body = `${translateMessage(ruleId, items[0].message)}${ranges ? '\n\nLinhas: ' + ranges : ''}\n\n<sub>dfl-bot-codereviwer</sub>`;
                if (anchor != null) {
                  reviewComments.push({ path: relativePath, line: anchor, body, category: ruleId });
                } else {
                  bodyOnlyLines.push({ path: relativePath, body, type: 'eslint' });
                }
              }
            }

            // Arquitetura â€” fileLevel: Ã¢ncora no final do arquivo (nunca linha 1); inline: agrupar por { file, category }
            const fileLevelIssues = [];
            const archByFileCategory = new Map();
            if (fs.existsSync('architecture-report.json')) {
              const archIssues = JSON.parse(fs.readFileSync('architecture-report.json', 'utf8'));
              for (const issue of archIssues) {
                const filePath = normPath(issue.file);
                if (!modifiedFiles.has(filePath)) continue;

                if (issue.fileLevel) {
                  const anchor = getAnchorLineEnd(filePath);
                  const msg = CANONICAL_MESSAGES[issue.category] || issue.message;
                  const body = `ğŸ’¡ ${msg}\n\n<sub>dfl-bot-codereviwer</sub>`;
                  if (anchor != null && anchor !== 1) {
                    reviewComments.push({ path: filePath, line: anchor, body, category: issue.category });
                  } else {
                    fileLevelIssues.push({ file: filePath, message: msg, ...issue });
                  }
                  continue;
                }

                const catKey = `${filePath}::${issue.category || 'other'}`;
                if (!archByFileCategory.has(catKey)) archByFileCategory.set(catKey, []);
                archByFileCategory.get(catKey).push(issue);
              }

              for (const [catKey, issues] of archByFileCategory) {
                const [filePath, category] = catKey.split('::');
                const lines = issues.map(i => i.line);
                const inDiff = lines.filter(l => isLineInDiff(filePath, l));
                const anchor = inDiff.length > 0 ? Math.min(...inDiff) : null;
                const ranges = compressLineNumbers(lines);
                const msg = CANONICAL_MESSAGES[category] || issues[0].message;
                const body = `ğŸ’¡ ${msg}${ranges ? '\n\nLinhas: ' + ranges : ''}\n\n<sub>dfl-bot-codereviwer</sub>`;
                if (anchor != null) {
                  reviewComments.push({ path: filePath, line: anchor, body, category });
                } else {
                  fileLevelIssues.push({ file: filePath, message: msg, category });
                }
              }
            }

            // Dedupe: (1) path::line::category (2) path + body idÃªntico (trim)
            const byKey = new Map();
            for (const c of reviewComments) {
              const key = `${c.path}::${c.line}::${c.category || ''}`;
              if (!byKey.has(key)) byKey.set(key, c);
            }
            const byPathBody = new Map();
            for (const c of byKey.values()) {
              const key = `${c.path}::${c.body.trim()}`;
              if (!byPathBody.has(key)) byPathBody.set(key, c);
            }
            const dedupedComments = [...byPathBody.values()].map(({ path, line, body }) => ({ path, line, body }));

            // â”€â”€ Montar body da review com issues file-level e body-only â”€â”€
            const event = hasLintErrors ? 'REQUEST_CHANGES' : 'COMMENT';
            let reviewBodyParts = [];

            if (dedupedComments.length > 0 || fileLevelIssues.length > 0 || bodyOnlyLines.length > 0) {
              reviewBodyParts.push(`**dfl-bot-codereviwer** â€” ${dedupedComments.length} comentÃ¡rio(s) nas linhas.`);

              if (fileLevelIssues.length > 0) {
                reviewBodyParts.push('');
                reviewBodyParts.push('**ObservaÃ§Ãµes gerais:**');
                for (const issue of fileLevelIssues) {
                  reviewBodyParts.push(`- ${issue.message}`);
                }
              }
              if (bodyOnlyLines.length > 0) {
                reviewBodyParts.push('');
                reviewBodyParts.push('**Sem linha no diff (revisar arquivo):**');
                for (const item of bodyOnlyLines) {
                  reviewBodyParts.push(`- \`${item.path}\`: ${item.body.replace(/\n/g, ' ').trim().slice(0, 120)}â€¦`);
                }
              }

              reviewBodyParts.push('');
              reviewBodyParts.push('Revise em **Files changed** e aprove quando estiver ok.');
            } else {
              reviewBodyParts.push('**dfl-bot-codereviwer**: Nenhum problema encontrado. âœ…');
            }

            const reviewBody = reviewBodyParts.join('\n');

            try {
              await github.rest.pulls.createReview({
                owner, repo, pull_number: pr_number, commit_id, event,
                body: reviewBody,
                comments: dedupedComments,
              });
              console.log('âœ… Review: ' + dedupedComments.length + ' inline + ' + fileLevelIssues.length + ' file-level (event: ' + event + ')');
            } catch (error) {
              console.error('Erro ao submeter review:', error.message);
              if (error.response) console.error('Detalhes:', JSON.stringify(error.response.data, null, 2));
            }

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Resumo do agente (comentÃ¡rio principal)
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: ğŸ¤– DLF Agent â€” Resumo da Review
        if: always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const { owner, repo } = context.repo;
            const pr_number = context.payload.pull_request?.number;

            if (!pr_number) return;

            // â”€â”€ Coletar dados â”€â”€
            let lintErrors = 0, lintWarnings = 0;
            let lintErrorFiles = [], lintWarningFiles = [];

            if (fs.existsSync('eslint-report.json')) {
              const report = JSON.parse(fs.readFileSync('eslint-report.json', 'utf8'));
              for (const file of report) {
                const relativePath = file.filePath.replace(process.cwd() + '/', '');
                if (file.errorCount > 0) {
                  lintErrors += file.errorCount;
                  lintErrorFiles.push(relativePath);
                }
                if (file.warningCount > 0) {
                  lintWarnings += file.warningCount;
                  lintWarningFiles.push(relativePath);
                }
              }
            }

            let archIssues = [];
            if (fs.existsSync('architecture-report.json')) {
              archIssues = JSON.parse(fs.readFileSync('architecture-report.json', 'utf8'));
            }

            const typecheckFailed = '${{ steps.typecheck.outcome }}' === 'failure';
            let typecheckOutput = '';
            if (fs.existsSync('typecheck-output.txt')) {
              typecheckOutput = fs.readFileSync('typecheck-output.txt', 'utf8');
            }

            // â”€â”€ Categorizar issues de arquitetura â”€â”€
            const archCategories = {};
            for (const issue of archIssues) {
              const cat = issue.category || 'other';
              if (!archCategories[cat]) archCategories[cat] = [];
              archCategories[cat].push(issue);
            }

            const totalIssues = lintErrors + lintWarnings + archIssues.length + (typecheckFailed ? 1 : 0);

            // â”€â”€ Se zero issues, elogie â”€â”€
            if (totalIssues === 0 && !typecheckFailed) {
              const body = [
                '## dfl-bot-codereviwer',
                '',
                '### âœ… PR impecÃ¡vel! ParabÃ©ns! ğŸ‰',
                '',
                'Nenhum problema encontrado. Seu cÃ³digo estÃ¡:',
                '- âœ… Sem erros de lint',
                '- âœ… Sem problemas de TypeScript',
                '- âœ… Seguindo os padrÃµes de arquitetura DLF',
                '',
                'Continue assim! CÃ³digo limpo e bem organizado facilita a vida de todo o time. ğŸ’ª',
                '',
                '---',
                '<sub>dfl-bot-codereviwer</sub>',
              ].join('\n');

              const marker = '## dfl-bot-codereviwer';
              const comments = await github.paginate(github.rest.issues.listComments, { owner, repo, issue_number: pr_number });
              const existing = comments.find(c => c.user?.login === 'github-actions[bot]' && c.body?.includes(marker));

              if (existing) {
                await github.rest.issues.updateComment({ owner, repo, comment_id: existing.id, body });
              } else {
                await github.rest.issues.createComment({ owner, repo, issue_number: pr_number, body });
              }
              return;
            }

            // â”€â”€ Construir resumo â”€â”€
            const sections = [];

            sections.push('## dfl-bot-codereviwer');
            sections.push('');
            sections.push('OlÃ¡! Analisei seu PR e aqui estÃ¡ o resumo da review:');
            sections.push('');

            // â”€â”€ Tabela resumo â”€â”€
            sections.push('### ğŸ“Š VisÃ£o Geral');
            sections.push('');
            sections.push('| Categoria | Quantidade | Status |');
            sections.push('|-----------|:----------:|:------:|');

            if (lintErrors > 0)
              sections.push(`| ğŸš« Erros de Lint | ${lintErrors} | âŒ Bloqueia merge |`);
            if (lintWarnings > 0)
              sections.push(`| âš ï¸ Avisos de Lint | ${lintWarnings} | Corrigir recomendado |`);
            if (typecheckFailed)
              sections.push(`| ğŸ”´ TypeScript | Erros | âŒ Bloqueia merge |`);
            if (archIssues.length > 0)
              sections.push(`| ğŸ’¡ SugestÃµes de Arquitetura | ${archIssues.length} | Melhorias recomendadas |`);

            sections.push('');

            // â”€â”€ Erros de TypeScript â”€â”€
            if (typecheckFailed && typecheckOutput) {
              sections.push('### ğŸ”´ Erros de TypeScript');
              sections.push('');
              const tsErrors = typecheckOutput.split('\n')
                .filter(l => /error TS\d+/.test(l))
                .slice(0, 10);
              if (tsErrors.length > 0) {
                sections.push('```');
                sections.push(tsErrors.join('\n'));
                sections.push('```');
              }
              sections.push('');
              sections.push('ğŸ’¡ **Dica**: Rode `npm run typecheck` localmente para ver todos os erros e corrigi-los antes do push.');
              sections.push('');
            }

            // â”€â”€ SeÃ§Ã£o de Arquitetura por categoria â”€â”€
            if (archIssues.length > 0) {
              sections.push('### ğŸ—ï¸ Arquitetura & OrganizaÃ§Ã£o');
              sections.push('');

              const categoryLabels = {
                'file-size': 'ğŸ“ Tamanho de Arquivo',
                'comment': 'ğŸ’¬ ComentÃ¡rios',
                'commented-code': 'ğŸ—‘ï¸ CÃ³digo Comentado',
                'todo-comment': 'ğŸ·ï¸ TODOs/FIXMEs',
                'inline-comment': 'ğŸ’¬ ComentÃ¡rios Inline',
                'unused-import': 'ğŸ§¹ Imports NÃ£o Utilizados',
                'console-log': 'ğŸ§¹ Console.log',
                'console-in-catch': 'ğŸ§¹ Console em Catch',
                'large-constant': 'ğŸ“¦ Constantes Extensas',
                'scattered-constants': 'ğŸ“¦ Constantes Dispersas',
                'multiple-components': 'ğŸ§© MÃºltiplos Componentes',
                'inline-type': 'ğŸ“ Types Inline',
                'long-function': 'ğŸ“ FunÃ§Ãµes Longas',
                'repetitive-pattern': 'ğŸ”„ PadrÃµes Repetitivos',
                'too-many-params': 'ğŸ“ Muitos ParÃ¢metros',
                'hook-placement': 'ğŸª Hooks',
                'hook-extraction': 'ğŸª ExtraÃ§Ã£o de Hooks',
                'supabase-in-component': 'ğŸ—„ï¸ Supabase no Componente',
                'fetch-in-component': 'ğŸŒ Fetch no Componente',
                'large-jsx': 'ğŸ§© JSX Extenso',
                'too-many-states': 'ğŸ§  Muitos Estados',
                'atomic-design': 'ğŸ—ï¸ Atomic Design',
                'duplicate-pattern': 'ğŸ”„ PadrÃµes Duplicados',
              };

              for (const [cat, issues] of Object.entries(archCategories)) {
                const label = categoryLabels[cat] || cat;
                const fileList = [...new Set(issues.map(i => i.file))];
                sections.push(`- **${label}** (${issues.length}) â€” ${fileList.map(f => `\`${f}\``).join(', ')}`);
              }
              sections.push('');
            }

            // â”€â”€ Dicas educacionais baseadas nos problemas encontrados â”€â”€
            sections.push('### ğŸ’¡ Dicas do DLF Agent');
            sections.push('');

            const tips = [];

            if (archCategories['comment'] || archCategories['inline-comment'] || archCategories['commented-code']) {
              tips.push('**CÃ³digo limpo nÃ£o precisa de comentÃ¡rios!** Use nomes descritivos para variÃ¡veis e funÃ§Ãµes. Se algo Ã© complexo demais para entender sem comentÃ¡rio, simplifique a lÃ³gica.');
            }
            if (archCategories['console-log'] || archCategories['console-in-catch']) {
              tips.push('**Substitua `console.log` por Toast!** O usuÃ¡rio nÃ£o vÃª o console. Use `toast.success()` para feedback positivo e `toast.error()` para erros. Para monitoramento, use Sentry.');
            }
            if (archCategories['large-constant'] || archCategories['scattered-constants']) {
              tips.push('**Constantes grandes merecem arquivo prÃ³prio.** Crie na pasta `/consts` quando uma constante passar de 10 linhas. Isso facilita imports seletivos e mantÃ©m os arquivos enxutos.');
            }
            if (archCategories['unused-import']) {
              tips.push('**Organize seus imports!** No VS Code, use `Ctrl+Shift+P â†’ Organize Imports` para remover imports nÃ£o utilizados automaticamente.');
            }
            if (archCategories['too-many-states'] || archCategories['hook-extraction']) {
              tips.push('**Componentes com 4+ useState precisam de um custom hook.** Extraia a lÃ³gica de estado para `hooks/use-nome.ts` â€” seu componente ficarÃ¡ mais limpo e testÃ¡vel.');
            }
            if (archCategories['multiple-components']) {
              tips.push('**Um arquivo, um componente.** No Atomic Design, cada componente tem seu prÃ³prio arquivo. Isso facilita testes, reutilizaÃ§Ã£o e code review.');
            }
            if (archCategories['inline-type']) {
              tips.push('**Types e interfaces devem ficar em `/interfaces` ou `/types`.** Isso permite reutilizaÃ§Ã£o e evita dependÃªncias circulares.');
            }
            if (archCategories['long-function'] || archCategories['repetitive-pattern']) {
              tips.push('**FunÃ§Ãµes devem fazer UMA coisa.** Se passou de 30 linhas, provavelmente faz coisas demais. Extraia validaÃ§Ãµes, transformaÃ§Ãµes e chamadas de API para funÃ§Ãµes auxiliares.');
            }
            if (archCategories['file-size']) {
              tips.push('**Nosso padrÃ£o Ã© mÃ¡ximo 200 linhas por arquivo.** Arquivos menores sÃ£o mais fÃ¡ceis de entender, testar e revisar. Divida em componentes, hooks e utilitÃ¡rios.');
            }
            if (archCategories['fetch-in-component'] || archCategories['supabase-in-component']) {
              tips.push('**Centralize chamadas de API.** Crie funÃ§Ãµes em `/lib` e consuma via custom hooks. Isso facilita cache, revalidaÃ§Ã£o e tratamento de erros consistente.');
            }

            // Sempre adicionar uma dica geral
            if (tips.length === 0) {
              tips.push('Bom trabalho no geral! Revise os avisos acima para deixar o cÃ³digo ainda melhor.');
            }

            tips.forEach((tip, i) => {
              sections.push(`${i + 1}. ${tip}`);
            });
            sections.push('');

            // â”€â”€ PrÃ³ximos passos â”€â”€
            sections.push('### âœ… PrÃ³ximos Passos');
            sections.push('');

            if (lintErrors > 0 || typecheckFailed) {
              sections.push('1. ğŸš« **Corrija os erros** â€” eles bloqueiam o merge do PR');
              sections.push('2. âš ï¸ **Resolva os avisos** â€” melhoram significativamente a qualidade');
              sections.push('3. ğŸ’¡ **Considere as sugestÃµes** â€” sÃ£o opcionais mas muito recomendadas');
              sections.push('');
              sections.push('**Rode localmente antes de fazer push:**');
              sections.push('```bash');
              sections.push('npm run lint      # verificar erros de lint');
              sections.push('npm run typecheck # verificar tipos TypeScript');
              sections.push('```');
            } else {
              sections.push('1. âš ï¸ **Resolva os avisos** â€” melhoram a qualidade do cÃ³digo');
              sections.push('2. ğŸ’¡ **Considere as sugestÃµes** â€” sÃ£o opcionais mas recomendadas');
              sections.push('3. âœ… O CI estÃ¡ passando â€” bom trabalho!');
            }

            sections.push('');
            sections.push('---');
            sections.push('<sub>dfl-bot-codereviwer</sub>');

            const body = sections.join('\n');
            const marker = '## dfl-bot-codereviwer';

            // Atualizar ou criar comentÃ¡rio
            const comments = await github.paginate(github.rest.issues.listComments, { owner, repo, issue_number: pr_number });
            const existing = comments.find(c => c.user?.login === 'github-actions[bot]' && c.body?.includes(marker));

            if (existing) {
              await github.rest.issues.updateComment({ owner, repo, comment_id: existing.id, body });
            } else {
              await github.rest.issues.createComment({ owner, repo, issue_number: pr_number, body });
            }

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Verificar se CI falhou
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Verificar se CI falhou
        if: always()
        run: |
          FAILED=0

          if [ -f eslint-report.json ]; then
            ERRORS=$(node -e "const r = require('./eslint-report.json'); console.log(r.reduce((acc, f) => acc + f.errorCount, 0))")
            if [ "$ERRORS" -gt 0 ]; then
              echo "âŒ Encontrados $ERRORS erros de lint"
              FAILED=1
            fi
          fi

          if [ "${{ steps.typecheck.outcome }}" == "failure" ]; then
            echo "âŒ TypeCheck falhou"
            FAILED=1
          fi

          if [ "$FAILED" -eq 1 ]; then
            echo ""
            echo "ğŸ’¡ Dica: Rode localmente antes de fazer push:"
            echo "   npm run lint"
            echo "   npm run typecheck"
            exit 1
          fi

          echo "âœ… CI passou com sucesso!"
