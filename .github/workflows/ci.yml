name: CI

on:
  pull_request:
  workflow_call:

permissions:
  contents: read
  pull-requests: write

jobs:
  ci:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Lint (gerar relatÃ³rio)
        id: lint
        run: npx eslint --config eslint.config.js . -f json -o eslint-report.json || true

      - name: Checagem de arquitetura
        id: architecture
        run: |
          node -e "
          const fs = require('fs');
          const path = require('path');

          // Carregar o checker (local ou do DLF-CI)
          let checkArchitecture;
          const localPath = './.github/workflows/architecture-check.js';
          if (fs.existsSync(localPath)) {
            checkArchitecture = require(localPath).checkArchitecture;
          } else {
            console.log('âš ï¸ architecture-check.js nÃ£o encontrado, pulando anÃ¡lise de arquitetura');
            fs.writeFileSync('architecture-report.json', '[]');
            process.exit(0);
          }

          const files = fs.readdirSync('.', { recursive: true })
            .filter(f => /\.(ts|tsx)$/.test(f) && !f.includes('node_modules') && !f.includes('.d.ts'));

          const issues = [];
          files.forEach(file => {
            const content = fs.readFileSync(file, 'utf8');
            const fileIssues = checkArchitecture(file, content);
            fileIssues.forEach(issue => {
              issues.push({ file, ...issue });
            });
          });

          fs.writeFileSync('architecture-report.json', JSON.stringify(issues, null, 2));
          console.log('ğŸ“Š AnÃ¡lise de arquitetura: ' + issues.length + ' issues encontradas');
          " || true

      - name: Typecheck
        id: typecheck
        run: npm run typecheck 2>&1 | tee typecheck-output.txt
        continue-on-error: true

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Review nas linhas do PR (Files changed) â€” bot submete review para o revisor aprovar
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: ğŸ¤– DLF Agent â€” Review nos arquivos (Files changed)
        if: always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');

            const { owner, repo } = context.repo;
            const pr_number = context.payload.pull_request?.number;
            const commit_id = context.payload.pull_request?.head?.sha;

            if (!pr_number || !commit_id) {
              console.log('NÃ£o Ã© um pull request ou falta commit_id, pulando review');
              return;
            }

            // Paths na API sÃ£o sempre com / (formato do GitHub)
            function normPath(p) {
              return p.replace(/\\/g, '/');
            }

            // â”€â”€ Buscar arquivos modificados no PR â”€â”€
            const { data: prFiles } = await github.rest.pulls.listFiles({
              owner, repo, pull_number: pr_number,
            });
            const modifiedFiles = new Set(prFiles.map(f => f.filename));

            // â”€â”€ Linhas que existem no diff (lado novo do arquivo) â”€â”€
            const diffLines = new Map();
            for (const file of prFiles) {
              const lines = new Set();
              if (file.patch) {
                const patchLines = file.patch.split('\n');
                let currentLine = 0;
                for (const patchLine of patchLines) {
                  const hunkMatch = patchLine.match(/^@@ -\d+(?:,\d+)? \+(\d+)/);
                  if (hunkMatch) {
                    currentLine = parseInt(hunkMatch[1], 10);
                    continue;
                  }
                  if (patchLine.startsWith('+')) {
                    lines.add(currentLine);
                    currentLine++;
                  } else if (patchLine.startsWith('-')) {
                    // nada
                  } else {
                    lines.add(currentLine);
                    currentLine++;
                  }
                }
              }
              diffLines.set(file.filename, lines);
            }

            function isLineInDiff(filePath, line) {
              const normalized = normPath(filePath);
              const fileLines = diffLines.get(normalized);
              if (!fileLines || fileLines.size === 0) return true;
              return fileLines.has(line);
            }

            // â”€â”€ TraduÃ§Ãµes do ESLint â€” mensagens curtas e diretas â”€â”€
            const translateMessage = (ruleId, message) => {
              const varName = message.split("'")[1] || '';
              const translations = {
                '@typescript-eslint/no-unused-vars': `ğŸ§¹ **NÃ£o utilizado**: \`${varName || 'variÃ¡vel'}\` â€” remova ou prefixe com \`_\`.`,
                '@typescript-eslint/no-unused-expressions': 'ğŸ§¹ **ExpressÃ£o sem efeito** â€” falta atribuiÃ§Ã£o ou chamada de funÃ§Ã£o?',
                '@typescript-eslint/no-explicit-any': 'ğŸ“ **Evite `any`** â€” defina o tipo correto em `/interfaces` ou use `unknown`.',
                '@typescript-eslint/no-var-requires': 'ğŸ“¦ **Use `import`** em vez de `require()`.',
                '@typescript-eslint/consistent-type-definitions': 'ğŸ“ **Use `interface`** em vez de `type` para objetos.',
                'no-inline-comments': 'ğŸ’¬ **ComentÃ¡rio inline** â€” remova ou mova para linha acima.',
                'line-comment-position': 'ğŸ’¬ **ComentÃ¡rio na posiÃ§Ã£o errada** â€” mova para linha acima.',
                'no-warning-comments': 'ğŸ·ï¸ **TODO/FIXME** â€” resolva antes de mergear.',
                'spaced-comment': 'ğŸ’¬ Adicione espaÃ§o apÃ³s `//`.',
                'max-lines': 'ğŸ“ **Arquivo muito longo** â€” ultrapassa 200 linhas. Divida o arquivo.',
                'max-lines-per-function': 'ğŸ“ **FunÃ§Ã£o muito longa** â€” extraia lÃ³gica para funÃ§Ãµes menores.',
                'max-statements': 'ğŸ“ **Muitas declaraÃ§Ãµes** â€” extraia para hooks ou utilitÃ¡rios.',
                'max-params': 'ğŸ“ **Muitos parÃ¢metros** â€” use um objeto de configuraÃ§Ã£o.',
                'complexity': 'ğŸ§  **Complexidade alta** â€” simplifique com early returns ou extraia funÃ§Ãµes.',
                'max-depth': 'ğŸ§  **Aninhamento excessivo** â€” use early returns.',
                'max-nested-callbacks': 'ğŸ§  **Callbacks aninhados** â€” use async/await.',
                'no-console': 'ğŸ§¹ **console detectado** â€” remova. Use Toast para feedback ao usuÃ¡rio.',
                '@next/next/no-html-link-for-pages': 'âš¡ Use `<Link>` do Next.js em vez de `<a>`.',
                '@next/next/no-img-element': 'âš¡ Use `<Image>` do Next.js em vez de `<img>`.',
                '@next/next/no-sync-scripts': 'âš¡ Use `<Script>` do Next.js.',
                '@next/next/no-page-custom-font': 'âš¡ Use `next/font` para fontes.',
                'react/jsx-key': 'ğŸ”‘ **Faltou `key`** â€” elementos em listas precisam de key Ãºnica.',
                'react/jsx-no-duplicate-props': 'ğŸš« **Props duplicadas** neste componente.',
                'react/jsx-no-undef': `ğŸš« **\`${varName || 'Componente'}\` nÃ£o definido** â€” verifique o import.`,
                'react/no-children-prop': 'ğŸš« Use `<Comp>conteÃºdo</Comp>` em vez de prop children.',
                'react/no-danger-with-children': 'ğŸš« NÃ£o use dangerouslySetInnerHTML com children.',
                'react/no-deprecated': 'âš ï¸ **API deprecated** â€” consulte a documentaÃ§Ã£o.',
                'react/no-direct-mutation-state': 'ğŸš« Use `setState()` ou useState setter.',
                'react/no-unescaped-entities': 'âš ï¸ Escape caracteres especiais em JSX.',
                'react/self-closing-comp': 'ğŸ§¹ Use `<Comp />` quando nÃ£o tem children.',
                'react-hooks/rules-of-hooks': 'ğŸš« **Hooks** sÃ³ podem ser chamados no nÃ­vel superior do componente.',
                'react-hooks/exhaustive-deps': 'âš ï¸ **DependÃªncias faltando** no array do hook.',
              };
              return translations[ruleId] || `**${ruleId}**: ${message}`;
            };

            // â”€â”€ Coletar TODOS os comentÃ¡rios para enviar numa Ãºnica Review â”€â”€
            const reviewComments = [];
            let hasLintErrors = false;

            // Regras ESLint que o architecture-check jÃ¡ cobre de forma consolidada
            // NÃ£o gerar comentÃ¡rios individuais para evitar poluiÃ§Ã£o
            const SKIP_ESLINT_RULES = new Set([
              'no-console',
              'no-inline-comments',
              'line-comment-position',
              'no-warning-comments',
              'spaced-comment',
              'max-lines',
              'max-lines-per-function',
              'max-statements',
              'max-params',
              '@typescript-eslint/no-unused-vars',
            ]);

            // ESLint â€” sÃ³ regras que o architecture-check NÃƒO cobre
            if (fs.existsSync('eslint-report.json')) {
              const report = JSON.parse(fs.readFileSync('eslint-report.json', 'utf8'));
              const filesWithErrors = report.filter(f => f.messages.length > 0);

              for (const file of filesWithErrors) {
                const relativePath = normPath(path.relative(process.cwd(), file.filePath));
                if (!modifiedFiles.has(relativePath)) continue;

                for (const msg of file.messages) {
                  if (!isLineInDiff(relativePath, msg.line)) continue;
                  if (msg.severity === 2) hasLintErrors = true;

                  // Pular regras que jÃ¡ sÃ£o cobertas pelo architecture-check consolidado
                  if (SKIP_ESLINT_RULES.has(msg.ruleId)) continue;

                  const translatedMessage = translateMessage(msg.ruleId, msg.message);

                  reviewComments.push({
                    path: relativePath,
                    line: msg.line,
                    body: `${translatedMessage}\n\n<sub>ğŸ¤– DLF Review Agent</sub>`,
                  });
                }
              }
            }

            // Arquitetura â€” separar fileLevel (resumo) de inline (linhas)
            const fileLevelIssues = [];
            if (fs.existsSync('architecture-report.json')) {
              const archIssues = JSON.parse(fs.readFileSync('architecture-report.json', 'utf8'));

              for (const issue of archIssues) {
                const filePath = normPath(issue.file);
                if (!modifiedFiles.has(filePath)) continue;

                // Issues file-level vÃ£o pro body da review, nÃ£o inline
                if (issue.fileLevel) {
                  fileLevelIssues.push({ file: filePath, ...issue });
                  continue;
                }

                if (!isLineInDiff(filePath, issue.line)) continue;

                reviewComments.push({
                  path: filePath,
                  line: issue.line,
                  body: `ğŸ’¡ ${issue.message}\n\n<sub>ğŸ¤– DLF Review Agent</sub>`,
                });
              }
            }

            // â”€â”€ Deduplicar: agrupar comentÃ¡rios da mesma linha em um sÃ³ â”€â”€
            const grouped = new Map();
            for (const c of reviewComments) {
              const key = `${c.path}::${c.line}`;
              if (grouped.has(key)) {
                grouped.get(key).body += '\n\n---\n\n' + c.body;
              } else {
                grouped.set(key, { ...c });
              }
            }
            const dedupedComments = [...grouped.values()];

            // â”€â”€ Montar body da review com issues file-level â”€â”€
            const event = hasLintErrors ? 'REQUEST_CHANGES' : 'COMMENT';
            let reviewBodyParts = [];

            if (dedupedComments.length > 0 || fileLevelIssues.length > 0) {
              reviewBodyParts.push(`ğŸ¤– **DLF Code Review Agent** â€” ${dedupedComments.length} comentÃ¡rio(s) nas linhas dos arquivos.`);

              if (fileLevelIssues.length > 0) {
                reviewBodyParts.push('');
                reviewBodyParts.push('**ObservaÃ§Ãµes gerais:**');
                for (const issue of fileLevelIssues) {
                  reviewBodyParts.push(`- ${issue.message}`);
                }
              }

              reviewBodyParts.push('');
              reviewBodyParts.push('Revise em **Files changed** e aprove quando estiver ok.');
            } else {
              reviewBodyParts.push('ğŸ¤– **DLF Code Review Agent**: Nenhum problema encontrado. âœ…');
            }

            const reviewBody = reviewBodyParts.join('\n');

            try {
              await github.rest.pulls.createReview({
                owner, repo, pull_number: pr_number, commit_id, event,
                body: reviewBody,
                comments: dedupedComments,
              });
              console.log('âœ… Review: ' + dedupedComments.length + ' inline + ' + fileLevelIssues.length + ' file-level (event: ' + event + ')');
            } catch (error) {
              console.error('Erro ao submeter review:', error.message);
              if (error.response) console.error('Detalhes:', JSON.stringify(error.response.data, null, 2));
            }

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Resumo do agente (comentÃ¡rio principal)
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: ğŸ¤– DLF Agent â€” Resumo da Review
        if: always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const { owner, repo } = context.repo;
            const pr_number = context.payload.pull_request?.number;

            if (!pr_number) return;

            // â”€â”€ Coletar dados â”€â”€
            let lintErrors = 0, lintWarnings = 0;
            let lintErrorFiles = [], lintWarningFiles = [];

            if (fs.existsSync('eslint-report.json')) {
              const report = JSON.parse(fs.readFileSync('eslint-report.json', 'utf8'));
              for (const file of report) {
                const relativePath = file.filePath.replace(process.cwd() + '/', '');
                if (file.errorCount > 0) {
                  lintErrors += file.errorCount;
                  lintErrorFiles.push(relativePath);
                }
                if (file.warningCount > 0) {
                  lintWarnings += file.warningCount;
                  lintWarningFiles.push(relativePath);
                }
              }
            }

            let archIssues = [];
            if (fs.existsSync('architecture-report.json')) {
              archIssues = JSON.parse(fs.readFileSync('architecture-report.json', 'utf8'));
            }

            const typecheckFailed = '${{ steps.typecheck.outcome }}' === 'failure';
            let typecheckOutput = '';
            if (fs.existsSync('typecheck-output.txt')) {
              typecheckOutput = fs.readFileSync('typecheck-output.txt', 'utf8');
            }

            // â”€â”€ Categorizar issues de arquitetura â”€â”€
            const archCategories = {};
            for (const issue of archIssues) {
              const cat = issue.category || 'other';
              if (!archCategories[cat]) archCategories[cat] = [];
              archCategories[cat].push(issue);
            }

            const totalIssues = lintErrors + lintWarnings + archIssues.length + (typecheckFailed ? 1 : 0);

            // â”€â”€ Se zero issues, elogie â”€â”€
            if (totalIssues === 0 && !typecheckFailed) {
              const body = [
                '## ğŸ¤– DLF Code Review Agent',
                '',
                '### âœ… PR impecÃ¡vel! ParabÃ©ns! ğŸ‰',
                '',
                'Nenhum problema encontrado. Seu cÃ³digo estÃ¡:',
                '- âœ… Sem erros de lint',
                '- âœ… Sem problemas de TypeScript',
                '- âœ… Seguindo os padrÃµes de arquitetura DLF',
                '',
                'Continue assim! CÃ³digo limpo e bem organizado facilita a vida de todo o time. ğŸ’ª',
                '',
                '---',
                '<sub>ğŸ¤– DLF Code Review Agent v2.0</sub>',
              ].join('\n');

              const marker = '## ğŸ¤– DLF Code Review Agent';
              const comments = await github.paginate(github.rest.issues.listComments, { owner, repo, issue_number: pr_number });
              const existing = comments.find(c => c.user?.login === 'github-actions[bot]' && c.body?.includes(marker));

              if (existing) {
                await github.rest.issues.updateComment({ owner, repo, comment_id: existing.id, body });
              } else {
                await github.rest.issues.createComment({ owner, repo, issue_number: pr_number, body });
              }
              return;
            }

            // â”€â”€ Construir resumo â”€â”€
            const sections = [];

            sections.push('## ğŸ¤– DLF Code Review Agent');
            sections.push('');
            sections.push('OlÃ¡! Analisei seu PR e aqui estÃ¡ o resumo da review:');
            sections.push('');

            // â”€â”€ Tabela resumo â”€â”€
            sections.push('### ğŸ“Š VisÃ£o Geral');
            sections.push('');
            sections.push('| Categoria | Quantidade | Status |');
            sections.push('|-----------|:----------:|:------:|');

            if (lintErrors > 0)
              sections.push(`| ğŸš« Erros de Lint | ${lintErrors} | âŒ Bloqueia merge |`);
            if (lintWarnings > 0)
              sections.push(`| âš ï¸ Avisos de Lint | ${lintWarnings} | Corrigir recomendado |`);
            if (typecheckFailed)
              sections.push(`| ğŸ”´ TypeScript | Erros | âŒ Bloqueia merge |`);
            if (archIssues.length > 0)
              sections.push(`| ğŸ’¡ SugestÃµes de Arquitetura | ${archIssues.length} | Melhorias recomendadas |`);

            sections.push('');

            // â”€â”€ Erros de TypeScript â”€â”€
            if (typecheckFailed && typecheckOutput) {
              sections.push('### ğŸ”´ Erros de TypeScript');
              sections.push('');
              const tsErrors = typecheckOutput.split('\n')
                .filter(l => /error TS\d+/.test(l))
                .slice(0, 10);
              if (tsErrors.length > 0) {
                sections.push('```');
                sections.push(tsErrors.join('\n'));
                sections.push('```');
              }
              sections.push('');
              sections.push('ğŸ’¡ **Dica**: Rode `npm run typecheck` localmente para ver todos os erros e corrigi-los antes do push.');
              sections.push('');
            }

            // â”€â”€ SeÃ§Ã£o de Arquitetura por categoria â”€â”€
            if (archIssues.length > 0) {
              sections.push('### ğŸ—ï¸ Arquitetura & OrganizaÃ§Ã£o');
              sections.push('');

              const categoryLabels = {
                'file-size': 'ğŸ“ Tamanho de Arquivo',
                'comment': 'ğŸ’¬ ComentÃ¡rios',
                'commented-code': 'ğŸ—‘ï¸ CÃ³digo Comentado',
                'todo-comment': 'ğŸ·ï¸ TODOs/FIXMEs',
                'inline-comment': 'ğŸ’¬ ComentÃ¡rios Inline',
                'unused-import': 'ğŸ§¹ Imports NÃ£o Utilizados',
                'console-log': 'ğŸ§¹ Console.log',
                'console-in-catch': 'ğŸ§¹ Console em Catch',
                'large-constant': 'ğŸ“¦ Constantes Extensas',
                'scattered-constants': 'ğŸ“¦ Constantes Dispersas',
                'multiple-components': 'ğŸ§© MÃºltiplos Componentes',
                'inline-type': 'ğŸ“ Types Inline',
                'long-function': 'ğŸ“ FunÃ§Ãµes Longas',
                'repetitive-pattern': 'ğŸ”„ PadrÃµes Repetitivos',
                'too-many-params': 'ğŸ“ Muitos ParÃ¢metros',
                'hook-placement': 'ğŸª Hooks',
                'hook-extraction': 'ğŸª ExtraÃ§Ã£o de Hooks',
                'supabase-in-component': 'ğŸ—„ï¸ Supabase no Componente',
                'fetch-in-component': 'ğŸŒ Fetch no Componente',
                'large-jsx': 'ğŸ§© JSX Extenso',
                'too-many-states': 'ğŸ§  Muitos Estados',
                'atomic-design': 'ğŸ—ï¸ Atomic Design',
                'duplicate-pattern': 'ğŸ”„ PadrÃµes Duplicados',
              };

              for (const [cat, issues] of Object.entries(archCategories)) {
                const label = categoryLabels[cat] || cat;
                const fileList = [...new Set(issues.map(i => i.file))];
                sections.push(`- **${label}** (${issues.length}) â€” ${fileList.map(f => `\`${f}\``).join(', ')}`);
              }
              sections.push('');
            }

            // â”€â”€ Dicas educacionais baseadas nos problemas encontrados â”€â”€
            sections.push('### ğŸ’¡ Dicas do DLF Agent');
            sections.push('');

            const tips = [];

            if (archCategories['comment'] || archCategories['inline-comment'] || archCategories['commented-code']) {
              tips.push('**CÃ³digo limpo nÃ£o precisa de comentÃ¡rios!** Use nomes descritivos para variÃ¡veis e funÃ§Ãµes. Se algo Ã© complexo demais para entender sem comentÃ¡rio, simplifique a lÃ³gica.');
            }
            if (archCategories['console-log'] || archCategories['console-in-catch']) {
              tips.push('**Substitua `console.log` por Toast!** O usuÃ¡rio nÃ£o vÃª o console. Use `toast.success()` para feedback positivo e `toast.error()` para erros. Para monitoramento, use Sentry.');
            }
            if (archCategories['large-constant'] || archCategories['scattered-constants']) {
              tips.push('**Constantes grandes merecem arquivo prÃ³prio.** Crie na pasta `/consts` quando uma constante passar de 10 linhas. Isso facilita imports seletivos e mantÃ©m os arquivos enxutos.');
            }
            if (archCategories['unused-import']) {
              tips.push('**Organize seus imports!** No VS Code, use `Ctrl+Shift+P â†’ Organize Imports` para remover imports nÃ£o utilizados automaticamente.');
            }
            if (archCategories['too-many-states'] || archCategories['hook-extraction']) {
              tips.push('**Componentes com 4+ useState precisam de um custom hook.** Extraia a lÃ³gica de estado para `hooks/use-nome.ts` â€” seu componente ficarÃ¡ mais limpo e testÃ¡vel.');
            }
            if (archCategories['multiple-components']) {
              tips.push('**Um arquivo, um componente.** No Atomic Design, cada componente tem seu prÃ³prio arquivo. Isso facilita testes, reutilizaÃ§Ã£o e code review.');
            }
            if (archCategories['inline-type']) {
              tips.push('**Types e interfaces devem ficar em `/interfaces` ou `/types`.** Isso permite reutilizaÃ§Ã£o e evita dependÃªncias circulares.');
            }
            if (archCategories['long-function'] || archCategories['repetitive-pattern']) {
              tips.push('**FunÃ§Ãµes devem fazer UMA coisa.** Se passou de 30 linhas, provavelmente faz coisas demais. Extraia validaÃ§Ãµes, transformaÃ§Ãµes e chamadas de API para funÃ§Ãµes auxiliares.');
            }
            if (archCategories['file-size']) {
              tips.push('**Nosso padrÃ£o Ã© mÃ¡ximo 200 linhas por arquivo.** Arquivos menores sÃ£o mais fÃ¡ceis de entender, testar e revisar. Divida em componentes, hooks e utilitÃ¡rios.');
            }
            if (archCategories['fetch-in-component'] || archCategories['supabase-in-component']) {
              tips.push('**Centralize chamadas de API.** Crie funÃ§Ãµes em `/lib` e consuma via custom hooks. Isso facilita cache, revalidaÃ§Ã£o e tratamento de erros consistente.');
            }

            // Sempre adicionar uma dica geral
            if (tips.length === 0) {
              tips.push('Bom trabalho no geral! Revise os avisos acima para deixar o cÃ³digo ainda melhor.');
            }

            tips.forEach((tip, i) => {
              sections.push(`${i + 1}. ${tip}`);
            });
            sections.push('');

            // â”€â”€ PrÃ³ximos passos â”€â”€
            sections.push('### âœ… PrÃ³ximos Passos');
            sections.push('');

            if (lintErrors > 0 || typecheckFailed) {
              sections.push('1. ğŸš« **Corrija os erros** â€” eles bloqueiam o merge do PR');
              sections.push('2. âš ï¸ **Resolva os avisos** â€” melhoram significativamente a qualidade');
              sections.push('3. ğŸ’¡ **Considere as sugestÃµes** â€” sÃ£o opcionais mas muito recomendadas');
              sections.push('');
              sections.push('**Rode localmente antes de fazer push:**');
              sections.push('```bash');
              sections.push('npm run lint      # verificar erros de lint');
              sections.push('npm run typecheck # verificar tipos TypeScript');
              sections.push('```');
            } else {
              sections.push('1. âš ï¸ **Resolva os avisos** â€” melhoram a qualidade do cÃ³digo');
              sections.push('2. ğŸ’¡ **Considere as sugestÃµes** â€” sÃ£o opcionais mas recomendadas');
              sections.push('3. âœ… O CI estÃ¡ passando â€” bom trabalho!');
            }

            sections.push('');
            sections.push('---');
            sections.push('<sub>ğŸ¤– DLF Code Review Agent v2.0 â€” Analisando PRs para que vocÃª aprenda mais rÃ¡pido</sub>');

            const body = sections.join('\n');
            const marker = '## ğŸ¤– DLF Code Review Agent';

            // Atualizar ou criar comentÃ¡rio
            const comments = await github.paginate(github.rest.issues.listComments, { owner, repo, issue_number: pr_number });
            const existing = comments.find(c => c.user?.login === 'github-actions[bot]' && c.body?.includes(marker));

            if (existing) {
              await github.rest.issues.updateComment({ owner, repo, comment_id: existing.id, body });
            } else {
              await github.rest.issues.createComment({ owner, repo, issue_number: pr_number, body });
            }

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Verificar se CI falhou
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Verificar se CI falhou
        if: always()
        run: |
          FAILED=0

          if [ -f eslint-report.json ]; then
            ERRORS=$(node -e "const r = require('./eslint-report.json'); console.log(r.reduce((acc, f) => acc + f.errorCount, 0))")
            if [ "$ERRORS" -gt 0 ]; then
              echo "âŒ Encontrados $ERRORS erros de lint"
              FAILED=1
            fi
          fi

          if [ "${{ steps.typecheck.outcome }}" == "failure" ]; then
            echo "âŒ TypeCheck falhou"
            FAILED=1
          fi

          if [ "$FAILED" -eq 1 ]; then
            echo ""
            echo "ğŸ’¡ Dica: Rode localmente antes de fazer push:"
            echo "   npm run lint"
            echo "   npm run typecheck"
            exit 1
          fi

          echo "âœ… CI passou com sucesso!"
